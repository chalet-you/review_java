package com.itheima._07正则表达式的演示;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
    目标：正则的分组、捕获、反向引用。

    举例：给你一段文本，请你找出所有四个数字连在一起的字串，并且这个四个数字要满足
          以下两个条件。
          一：第一位与第四位相同
          二：第二位与第三位相同
          比如 1221，5775，....

    要解决以上问题，我们要了解正则表达式的几个概念

    1、分组
          我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们
          可以看作是一个子表达式 / 一个分组

    2、捕获
          把正则表达式中子表达式 / 分组匹配的内容，保存在内存中以数字编号或
          显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个
          出现的分组的组号为 1 ，第二个为 2 ，以此类推。以 0 代表的是整个正则式

    3、反向引用
           圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的
           匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也
           可以是在正则表达式外部，内部反向引用 \\ 分组号，外部反向引用 $ 分组号


    小案例：
             1、要匹配两个连续的相同数字：                         (\\d)\\1
             2、要匹配五个连续的相同的数字：                       (\\d)\\1{4}  等价与(\\d)\\1\\1\\1\\1
             3、要匹配个位与千位相同，十位与百位相同的数 5225,1551  (\\d)(\\d)\\2\\1
    思考题：
            请在字符串中检索商品编号，形式如：12321-333999111这样的号码，要求满足前面是一个
            五位数，然后一个 - 号，然后是一个九位数，连续的每三位要相同。
            "\\d{5}-(\\d)\\1\\1(\\d)\\2\\2(\\d)\\3\\3"   或者   "\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}"

*/
public class _08RegexDemo {
    public static void main(String[] args) {
        String context = "h1234e9876llo33333 y1551ouxuan11 chalet12 yx22 mmm12345 nnn fink12321-333999111 spark hive hbase";
        // 要匹配两个连续的相同数字
        // String regex = "(\\d)\\1";

        // 要匹配五个连续的相同的数字
        //String regex = "(\\d)\\1{4}";

        // 要匹配个位与千位相同，十位与百位相同的数 5225,1551
        //String regex = "(\\d)(\\d)\\2\\1";

        /**
        请在字符串中检索商品编号，形式如：12321-333999111这样的号码，要求满足前面是一个
        五位数，然后一个 - 号，然后是一个九位数，连续的每三位要相同。
         "\\d{5}-(\\d)\\1\\1(\\d)\\2\\2(\\d)\\3\\3"
         或者
         "\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}"
         */
        String regex = "\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(context);
        // 因为会匹配多次，所以用 while
        while (matcher.find()){
            //  group() 底层还是调用的 group(0)
            System.out.println("找到了："+ matcher.group());
        }
    }

}
